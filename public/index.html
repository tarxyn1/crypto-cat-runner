<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Crypto Cat Runner — WebApp</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    html,body{margin:0;background:#0b1020;color:#e7f3ff;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
    .hud{display:flex;justify-content:center;gap:12px;flex-wrap:wrap;margin:10px 8px;font-weight:600}
    .pill{background:#0f1730;border:1px solid #1e2747;border-radius:999px;padding:6px 10px}
    canvas{width:min(960px,95vw);height:auto;display:block;margin:8px auto 16px;background:#0a0f1e;
           border:1px solid #1e2747;border-radius:12px;box-shadow:0 10px 40px rgba(0,0,0,.35);image-rendering:pixelated}
    .row{display:flex;justify-content:center;gap:10px;margin:8px 0}
    button{cursor:pointer;border:1px solid #1e2747;background:#162041;color:#e7f3ff;border-radius:10px;padding:8px 12px}
  </style>
</head>
<body>
  <div class="hud">
    <div class="pill">↑/Space — прыжок • R — рестарт • P — пауза • K — смена цвета кота</div>
  </div>
  <div class="row">
    <button id="save">Сохранить рекорд</button>
    <button id="best">Показать рекорд</button>
  </div>
  <canvas id="game" width="960" height="540"></canvas>

  <script>
    // --- Telegram WebApp integration
    const tg = window.Telegram && window.Telegram.WebApp;
    let currentUser = null;
    (async () => {
      try {
        tg && tg.ready();
        tg && tg.expand();
        const theme = tg?.themeParams || {};
        // Validate initData on backend
        if (tg?.initData) {
          const res = await fetch('/api/validate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ initData: tg.initData })
          });
          const j = await res.json();
          if (!j.ok) console.warn('initData invalid', j);
          // parse user
          const urlp = new URLSearchParams(tg.initData);
          const userJSON = urlp.get('user');
          if (userJSON) currentUser = JSON.parse(userJSON);
        }
      } catch (e) { console.warn(e); }
    })();
  </script>

  <script>
    // === GAME (shortened: Pico Park cat + coins + enemies)
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    const GROUND_Y = 420, GRAVITY = 0.9, JUMP_VELOCITY = -17;
    const START_SPEED = 6, SPEEDUP = 0.0009;
    const SPAWN_COOLDOWN = { coin: 1000, enemy: 1100 };
    const WORLD = { speed: START_SPEED, t: 0 };

    let coins = 0, alive = true, paused = false;

    const CELL = 6;
    const CAT_W = 8*CELL, CAT_H = 9*CELL;
    const player = { kind:'player', x:150, y:GROUND_Y, w:CAT_W, h:CAT_H, vy:0, onGround:true };

    const objects = { coins: [], enemies: [], particles: [] };
    let lastSpawn = { coin: 0, enemy: 0 };

    const CAT_COLORS = ['#f4a261','#5bb6ff','#ff9bb0','#ffd166','#8fff8b','#bba0ff'];
    let catColorIndex = 0;

    const rand = (a,b)=>Math.random()*(b-a)+a;
    const getRect = e => (e.kind==='player'||e.kind==='enemy') ? {x:e.x, y:e.y - e.h, w:e.w, h:e.h}
                                                               : {x:e.x, y:e.y, w:e.w, h:e.h};
    function aabb(A,B){ const a=getRect(A), b=getRect(B);
      return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y; }
    function reset(){
      coins=0; alive=true; paused=false;
      WORLD.speed=START_SPEED; WORLD.t=0;
      objects.coins.length=0; objects.enemies.length=0; objects.particles.length=0;
      Object.assign(player,{ x:150, y:GROUND_Y, vy:0, onGround:true });
    }
    function drawBackground(){
      ctx.fillStyle='#081326'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.globalAlpha=.5;
      for(let i=0;i<120;i++){
        const x=((i*83+WORLD.t*0.06)%(canvas.width+200))-100, y=(i*53)%260+10;
        ctx.fillStyle='#5cc8ff'; ctx.fillRect(x,y,2,2);
      }
      ctx.globalAlpha=1;
      ctx.fillStyle='#0b152f'; ctx.fillRect(0,GROUND_Y,canvas.width,canvas.height-GROUND_Y);
      ctx.strokeStyle='#1a2a55';
      for(let x=(-WORLD.t*1.2)%40;x<canvas.width;x+=40){
        ctx.beginPath(); ctx.moveTo(x,GROUND_Y); ctx.lineTo(x+80,canvas.height); ctx.stroke();
      }
    }
    const CAT_MAP = [
      [1,1,0,0,0,0,1,1],
      [1,1,1,1,1,1,1,1],
      [1,1,2,1,1,2,1,1],
      [1,1,1,1,1,1,1,1],
      [0,1,1,1,1,1,1,0],
      [0,0,1,1,1,1,0,0],
      [0,0,0,3,3,0,0,0],
      [0,0,1,0,0,1,0,0],
      [0,0,1,0,0,1,0,0],
    ];
    function drawPicoCat(){
      const x0 = player.x, y0 = player.y - CAT_H;
      const BODY = CAT_COLORS[catColorIndex], EYE = '#000000', TOOTH = '#ffffff';
      const px = player.w/8, py = player.h/9;
      for(let r=0;r<CAT_MAP.length;r++)
        for(let c=0;c<CAT_MAP[0].length;c++)
          if(CAT_MAP[r][c])
            { ctx.fillStyle='#111'; ctx.fillRect(x0+c*px-1, y0+r*py-1, px+2, py+2); }
      for(let r=0;r<CAT_MAP.length;r++){
        for(let c=0;c<CAT_MAP[0].length;c++){
          const cell = CAT_MAP[r][c]; if(!cell) continue;
          ctx.fillStyle = (cell===1)?BODY:(cell===2)?EYE:TOOTH;
          ctx.fillRect(x0+c*px, y0+r*py, px, py);
        }
      }
    }
    function drawEnemy(e){
      const top = e.y - e.h;
      ctx.fillStyle='#ff6666'; ctx.fillRect(e.x, top, e.w, e.h);
      ctx.fillStyle='#3a0f0f'; ctx.fillRect(e.x+e.w/2-3, top+8, 6, 6);
    }
    const COIN_SKINS = ['USDT','BTC','TON'];
    function spawnCoin(){
      const r=16, top=GROUND_Y - 80 - Math.random()*110;
      const skin=COIN_SKINS[Math.floor(Math.random()*COIN_SKINS.length)];
      objects.coins.push({ kind:'coin', x:canvas.width+rand(0,120), y:top, w:r*2, h:r*2, r,
        skin, spin:rand(0,1000), shimmer:rand(0,1000) });
    }
    function coinPalette(s){
      switch(s){
        case 'USDT': return { inner:'#22ffcc', outer:'#008f73', logo:'#ffffff' };
        case 'BTC':  return { inner:'#ffb347', outer:'#d78100', logo:'#1a1a1a' };
        case 'TON':  return { inner:'#53b6ff', outer:'#0b6ed1', logo:'#ffffff' };
        default:     return { inner:'#ffd94d', outer:'#b88400', logo:'#ffffff' };
      }
    }
    function drawCoinLogo(s){
      switch(s){
        case 'USDT':
          ctx.fillRect(-12,-2,24,4); ctx.fillRect(-3,-2,6,16); ctx.clearRect(-9,6,18,4); break;
        case 'BTC':
          ctx.fillRect(-3,-12,6,24); ctx.beginPath(); ctx.arc(0,-6,8,Math.PI*0.9,Math.PI*0.1,false);
          ctx.arc(0,6,8,Math.PI*0.9,Math.PI*0.1,false); ctx.fill(); break;
        case 'TON':
          ctx.beginPath(); ctx.moveTo(0,-10); ctx.lineTo(10,0); ctx.lineTo(0,12); ctx.lineTo(-10,0); ctx.closePath();
          ctx.strokeStyle=ctx.fillStyle; ctx.stroke(); break;
      }
    }
    function drawCoin(c){
      const {x,y,r,skin}=c, pal=coinPalette(skin);
      const squash=0.12*Math.sin((WORLD.t+c.spin)*0.01);
      ctx.save(); ctx.translate(x+r,y+r); ctx.scale(1+squash,1-squash);
      ctx.rotate(((WORLD.t+c.spin)*0.006)%(Math.PI*2));
      const g=ctx.createRadialGradient(0,0,r*0.25,0,0,r); g.addColorStop(0,pal.inner); g.addColorStop(1,pal.outer);
      ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(255,255,255,.35)'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(0,0,r-1.5,0,Math.PI*2); ctx.stroke();
      ctx.save(); ctx.rotate(Math.PI*0.25);
      ctx.globalAlpha=0.25+0.35*((Math.sin((WORLD.t+c.shimmer)*0.008)+1)/2);
      const grd=ctx.createLinearGradient(-r,-r,r,r);
      grd.addColorStop(0,'rgba(255,255,255,0)'); grd.addColorStop(0.5,'rgba(255,255,255,0.8)'); grd.addColorStop(1,'rgba(255,255,255,0)');
      ctx.fillStyle=grd; ctx.fillRect(-r,-r,r*2,r*2); ctx.restore();
      ctx.fillStyle=pal.logo; ctx.strokeStyle=pal.logo; drawCoinLogo(skin);
      ctx.restore();
    }
    function spawnEnemy(){
      const w=44,h=32;
      objects.enemies.push({ kind:'enemy', x:canvas.width+rand(0,120), y:GROUND_Y, w,h });
    }
    function jump(){ if(alive && player.onGround){ player.vy=JUMP_VELOCITY; player.onGround=false; } }
    document.addEventListener('keydown',e=>{
      if (e.code==='Space'||e.code==='ArrowUp'){ e.preventDefault(); jump(); }
      if (e.code==='KeyR') reset();
      if (e.code==='KeyP') paused=!paused;
      if (e.code==='KeyK') catColorIndex=(catColorIndex+1)%CAT_COLORS.length;
    });
    canvas.addEventListener('pointerdown', jump);

    let last = performance.now();
    function loop(now){
      const dt=now-last; last=now;
      if(!paused && alive){
        WORLD.t+=dt; WORLD.speed+=SPEEDUP*dt;
        if(now-lastSpawn.coin>SPAWN_COOLDOWN.coin){spawnCoin(); lastSpawn.coin=now;}
        if(now-lastSpawn.enemy>SPAWN_COOLDOWN.enemy){spawnEnemy(); lastSpawn.enemy=now;}
        player.vy+=GRAVITY; player.y+=player.vy;
        if(player.y>=GROUND_Y){player.y=GROUND_Y; player.vy=0; player.onGround=true;}
        for(let i=objects.coins.length-1;i>=0;i--){
          const c=objects.coins[i]; c.x-=WORLD.speed;
          if(aabb(c,player)){ coins++; objects.coins.splice(i,1); }
          else if(c.x+c.w<-10) objects.coins.splice(i,1);
        }
        for(let i=objects.enemies.length-1;i>=0;i--){
          const e=objects.enemies[i]; e.x-=WORLD.speed*1.05;
          if(aabb(e,player)){ alive=false; }
          else if(e.x+e.w<-10) objects.enemies.splice(i,1);
        }
      }
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawBackground();
      objects.coins.forEach(drawCoin);
      objects.enemies.forEach(drawEnemy);
      drawPicoCat();
      ctx.fillStyle='#e7f3ff'; ctx.font='20px system-ui, sans-serif';
      ctx.fillText(`Монеты: ${coins}`, 20, 36);
      if(!alive){
        ctx.fillStyle='#ffb3c0'; ctx.font='28px system-ui, sans-serif';
        ctx.fillText('Игра окончена — R для рестарта', canvas.width/2-180, canvas.height/2);
      }
      requestAnimationFrame(loop);
    }
    reset(); requestAnimationFrame(t=>{ last=t; loop(t); });

    // Buttons: save / best
    document.getElementById('save').onclick = async () => {
      if (!currentUser) return alert('Нет данных пользователя Telegram');
      const res = await fetch('/api/score', {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ user_id: currentUser.id, score: coins })
      });
      const j = await res.json();
      alert('Сохранено. Лучший: ' + j.best);
    };
    document.getElementById('best').onclick = async () => {
      if (!currentUser) return alert('Нет данных пользователя Telegram');
      const res = await fetch('/api/score/' + currentUser.id);
      const j = await res.json();
      alert('Лучший счёт: ' + j.best);
    };
  </script>
</body>
</html>
